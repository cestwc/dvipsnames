<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaTeX Color Matcher</title>
    <style>
        :root {
            --primary: #007bff;
            --bg: #f8f9fa;
            --text: #333;
            --border: #ddd;
        }
        body {
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 { margin-bottom: 0.5rem; }
        .subtitle { color: #666; margin-bottom: 2rem; }
        
        /* Controls */
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            align-items: end;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label { font-size: 0.9em; font-weight: 600; margin-bottom: 5px; }
        input, select {
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 1rem;
        }
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        /* Preview Area */
        .preview-container {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            align-items: center;
        }
        .color-box-large {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px #ccc;
        }
        .preview-label { text-align: center; font-size: 0.85em; margin-top: 5px; color: #666; }

        /* Results Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }
        th { background: #f1f3f5; font-weight: 600; }
        code {
            background: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #d63384;
            font-size: 1.1em;
        }
        .vis-box {
            width: 50px;
            height: 30px;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.1);
            vertical-align: middle;
            margin-right: 10px;
        }
        
        /* Loading Spinner */
        .spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <h1>LaTeX Color Matcher</h1>
    <div class="subtitle">Find the closest xcolor approximation (e.g., <code>Green!20!White</code>)</div>

    <div class="card">
        <div class="controls">
            <div class="control-group">
                <label>Target Hex</label>
                <input type="text" id="targetHex" value="DCFFDC" placeholder="#RRGGBB">
            </div>
            <div class="control-group">
                <label>Mix Depth (Bangs)</label>
                <select id="depth">
                    <option value="1">1 (e.g. Red!50!Blue)</option>
                    <option value="2" selected>2 (e.g. Red!50!Blue!30!White)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Metric</label>
                <select id="metric">
                    <option value="rgb">RGB (Euclidean)</option>
                    <option value="lab" selected>CIEDE2000 (Perceptual)</option>
                </select>
            </div>
            <div class="control-group" style="flex-direction: row; align-items: center;">
                <button id="solveBtn" onclick="runSolver()">Find Match</button>
                <div id="spinner" class="spinner"></div>
            </div>
        </div>

        <div class="preview-container">
            <div>
                <div id="targetPreview" class="color-box-large" style="background: #DCFFDC;"></div>
                <div class="preview-label">Target</div>
            </div>
            <div style="font-size: 20px; color: #999;">&rarr;</div>
            <div>
                <div id="resultPreview" class="color-box-large" style="background: #fff;"></div>
                <div class="preview-label">Best Match</div>
            </div>
        </div>
    </div>

    <div class="card">
        <h3>Top Results</h3>
        <table id="resultsTable">
            <thead>
                <tr>
                    <th style="width: 50px;">Rank</th>
                    <th style="width: 80px;">Diff</th>
                    <th>Visual</th>
                    <th>LaTeX Code</th>
                </tr>
            </thead>
            <tbody>
                <tr><td colspan="4" style="text-align:center; color:#999;">Click "Find Match" to start</td></tr>
            </tbody>
        </table>
    </div>

<script>
// ==========================================
// 1. DATA: Standard + Dvipsnames
// ==========================================

// Helper: RGB 0-1 to CMYK
function rgbToCmykNaive(r, g, b) {
    let k = 1 - Math.max(r, g, b);
    if (k === 1) return [0, 0, 0, 1];
    return [(1-r-k)/(1-k), (1-g-k)/(1-k), (1-b-k)/(1-k), k];
}

// 19 Standard LaTeX Colors (RGB Definitions)
const STANDARD_BASES_RGB = {
    "red":       [1, 0, 0],
    "green":     [0, 1, 0], // The pure green you needed
    "blue":      [0, 0, 1],
    "cyan":      [0, 1, 1],
    "magenta":   [1, 0, 1],
    "yellow":    [1, 1, 0],
    "black":     [0, 0, 0],
    "white":     [1, 1, 1],
    "gray":      [0.5, 0.5, 0.5],
    "darkgray":  [0.25, 0.25, 0.25],
    "lightgray": [0.75, 0.75, 0.75],
    "brown":     [0.75, 0.5, 0.25],
    "lime":      [0.75, 1.0, 0.0],
    "olive":     [0.5, 0.5, 0.0],
    "orange":    [1.0, 0.5, 0.0],
    "pink":      [1.0, 0.75, 0.75],
    "purple":    [0.75, 0.0, 0.25],
    "teal":      [0.0, 0.5, 0.5],
    "violet":    [0.5, 0.0, 0.5]
};

// 68 dvipsnames (Hardcoded RGB approximations from xcolor manual)
const DVIPSNAMES_RGB = {
    "Apricot": [1.0, 0.8, 0.6], "Aquamarine": [0.0, 1.0, 1.0], "Bittersweet": [0.76, 0.01, 0.0],
    "Black": [0,0,0], "Blue": [0,0,1], "BlueGreen": [0.0, 1.0, 0.8], "BlueViolet": [0.54, 0.17, 0.89],
    "BrickRed": [0.72, 0.0, 0.0], "Brown": [0.4, 0.0, 0.0], "BurntOrange": [1.0, 0.6, 0.0],
    "CadetBlue": [0.38, 0.43, 0.6], "CarnationPink": [1.0, 0.43, 0.78], "Cerulean": [0.0, 0.7, 1.0],
    "CornflowerBlue": [0.39, 0.58, 0.93], "Cyan": [0,1,1], "Dandelion": [1.0, 0.71, 0.16],
    "DarkOrchid": [0.6, 0.2, 0.8], "Emerald": [0.0, 1.0, 0.5], "ForestGreen": [0.0, 0.6, 0.0],
    "Fuchsia": [1.0, 0.0, 1.0], "Goldenrod": [1.0, 0.9, 0.1], "Gray": [0.5,0.5,0.5],
    "Green": [0.0, 0.65, 0.31], "GreenYellow": [0.85, 1.0, 0.31], "JungleGreen": [0.0, 1.0, 0.5],
    "Lavender": [1.0, 0.6, 1.0], "LimeGreen": [0.5, 1.0, 0.0], "Magenta": [1,0,1],
    "Mahogany": [0.75, 0.0, 0.0], "Maroon": [0.69, 0.0, 0.0], "Melon": [1.0, 0.5, 0.5],
    "MidnightBlue": [0.1, 0.1, 0.44], "Mulberry": [0.64, 0.08, 0.57], "NavyBlue": [0.06, 0.46, 1.0],
    "OliveGreen": [0.0, 0.6, 0.0], "Orange": [1.0, 0.5, 0.0], "OrangeRed": [1.0, 0.0, 0.5],
    "Orchid": [0.68, 0.36, 1.0], "Peach": [1.0, 0.5, 0.3], "Periwinkle": [0.5, 0.5, 1.0],
    "PineGreen": [0.0, 0.75, 0.5], "Plum": [0.5, 0.0, 1.0], "ProcessBlue": [0.04, 0.7, 1.0],
    "Purple": [0.5, 0.0, 0.5], "RawSienna": [0.55, 0.0, 0.0], "Red": [1,0,0],
    "RedOrange": [1.0, 0.23, 0.13], "RedViolet": [0.67, 0.05, 0.57], "Rhodamine": [1.0, 0.0, 1.0],
    "RoyalBlue": [0.0, 0.44, 1.0], "RoyalPurple": [0.47, 0.2, 0.73], "RubineRed": [1.0, 0.0, 0.54],
    "Salmon": [1.0, 0.47, 0.62], "SeaGreen": [0.2, 1.0, 0.5], "Sepia": [0.3, 0.1, 0.0],
    "SkyBlue": [0.38, 1.0, 0.88], "SpringGreen": [0.0, 1.0, 0.5], "Tan": [0.86, 0.58, 0.44],
    "TealBlue": [0.0, 0.5, 0.7], "Thistle": [0.85, 0.64, 0.85], "Turquoise": [0.0, 1.0, 0.8],
    "Violet": [0.5, 0.0, 0.5], "VioletRed": [1.0, 0.2, 0.6], "White": [1,1,1],
    "WildStrawberry": [1.0, 0.04, 0.61], "Yellow": [1,1,0], "YellowGreen": [0.6, 1.0, 0.2],
    "YellowOrange": [1.0, 0.6, 0.0]
};

// Compile full dictionary (Standard bases overwrite dvipsnames if duplicates exist, ensuring "green" is pure)
let COLOR_LIB = {};
for (let [name, rgb] of Object.entries(DVIPSNAMES_RGB)) {
    COLOR_LIB[name] = rgbToCmykNaive(...rgb);
}
for (let [name, rgb] of Object.entries(STANDARD_BASES_RGB)) {
    COLOR_LIB[name] = rgbToCmykNaive(...rgb);
}

// ==========================================
// 2. MATH ENGINE
// ==========================================

function cmykMix(c1, c2, p) {
    let ratio = p / 100.0;
    return c1.map((val, i) => ratio * val + (1.0 - ratio) * c2[i]);
}

function cmykToRgbNaive(cmyk) {
    let [c, m, y, k] = cmyk;
    let r = (1.0 - c) * (1.0 - k);
    let g = (1.0 - m) * (1.0 - k);
    let b = (1.0 - y) * (1.0 - k);
    return [r, g, b];
}

function rgbToLab(rgb) {
    let [r, g, b] = rgb.map(c => {
        return (c > 0.04045) ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92;
    });
    let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
    let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
    let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
    
    [x, y, z] = [x, y, z].map(val => val > 0.008856 ? Math.pow(val, 1/3) : (7.787 * val) + 16/116);
    return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
}

function deltaE2000(lab1, lab2) {
    let [L1, a1, b1] = lab1;
    let [L2, a2, b2] = lab2;
    let avgL = (L1 + L2) / 2;
    let C1 = Math.sqrt(a1*a1 + b1*b1);
    let C2 = Math.sqrt(a2*a2 + b2*b2);
    let avgC = (C1 + C2) / 2;
    let G = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));
    
    let a1p = (1 + G) * a1;
    let a2p = (1 + G) * a2;
    let C1p = Math.sqrt(a1p*a1p + b1*b1);
    let C2p = Math.sqrt(a2p*a2p + b2*b2);
    let avgCp = (C1p + C2p) / 2;
    
    let h1p = (C1p === 0) ? 0 : Math.atan2(b1, a1p) * 180 / Math.PI;
    if (h1p < 0) h1p += 360;
    let h2p = (C2p === 0) ? 0 : Math.atan2(b2, a2p) * 180 / Math.PI;
    if (h2p < 0) h2p += 360;
    
    let deltaHp = h2p - h1p;
    if (Math.abs(deltaHp) > 180) deltaHp -= (h2p > h1p) ? 360 : -360;
    let deltaH_dist = 2 * Math.sqrt(C1p * C2p) * Math.sin(deltaHp * Math.PI / 360);
    
    let avgHp = (Math.abs(h1p - h2p) > 180) ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
    let T = 1 - 0.17 * Math.cos((avgHp - 30) * Math.PI / 180) +
                0.24 * Math.cos((2 * avgHp) * Math.PI / 180) +
                0.32 * Math.cos((3 * avgHp + 6) * Math.PI / 180) -
                0.20 * Math.cos((4 * avgHp - 63) * Math.PI / 180);
                
    let SL = 1 + (0.015 * Math.pow(avgL - 50, 2)) / Math.sqrt(20 + Math.pow(avgL - 50, 2));
    let SC = 1 + 0.045 * avgCp;
    let SH = 1 + 0.015 * avgCp * T;
    
    let RT = -2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7))) * Math.sin((60 * Math.exp(-Math.pow((avgHp - 275) / 25, 2))) * Math.PI / 180);
              
    return Math.sqrt(
        Math.pow((L2 - L1) / SL, 2) +
        Math.pow((C2p - C1p) / SC, 2) +
        Math.pow(deltaH_dist / SH, 2) +
        RT * (C2p - C1p) / SC * deltaH_dist / SH
    );
}

function distEuclidean(rgb1, rgb2) {
    return Math.sqrt(
        Math.pow((rgb1[0]-rgb2[0])*255, 2) + 
        Math.pow((rgb1[1]-rgb2[1])*255, 2) + 
        Math.pow((rgb1[2]-rgb2[2])*255, 2)
    );
}

// ==========================================
// 3. SOLVER & UI
// ==========================================

function hexToRgb(hex) {
    hex = hex.replace(/^#/, '');
    if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
    let bigint = parseInt(hex, 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255].map(x => x/255);
}

async function runSolver() {
    const btn = document.getElementById('solveBtn');
    const spinner = document.getElementById('spinner');
    const tableBody = document.querySelector('#resultsTable tbody');
    
    btn.disabled = true;
    spinner.style.display = 'block';
    tableBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">Calculating...</td></tr>';
    
    // Allow UI to update before heavy calc
    await new Promise(r => setTimeout(r, 50));

    try {
        const targetHex = document.getElementById('targetHex').value;
        const maxDepth = parseInt(document.getElementById('depth').value);
        const metricType = document.getElementById('metric').value;
        const targetRgb = hexToRgb(targetHex);
        const targetLab = rgbToLab(targetRgb);

        document.getElementById('targetPreview').style.backgroundColor = '#' + targetHex.replace(/^#/, '');

        const getGap = (candRgb) => {
            if (metricType === 'lab') {
                return deltaE2000(rgbToLab(candRgb), targetLab);
            }
            return distEuclidean(candRgb, targetRgb);
        };

        // --- Solver Logic ---
        const STEP_SIZE = 5;
        const BEAM_WIDTH = 100;

        // Init Generation (Depth 0)
        let currentGen = [];
        for (let [name, cmyk] of Object.entries(COLOR_LIB)) {
            let rgb = cmykToRgbNaive(cmyk);
            currentGen.push({
                gap: getGap(rgb),
                cmyk: cmyk,
                expr: name,
                rgb: rgb
            });
        }

        let bestResults = []; // Store top from each depth

        // Add Depth 0 best
        currentGen.sort((a,b) => a.gap - b.gap);
        bestResults.push(currentGen[0]);

        // Loop for depth
        for (let k = 1; k <= maxDepth; k++) {
            let nextGen = [];
            let candidates = currentGen.slice(0, BEAM_WIDTH);

            for (let cand of candidates) {
                // Mix with all base colors
                for (let [bName, bCmyk] of Object.entries(COLOR_LIB)) {
                    // optimization: avoid redundant mixing "Red!50!Red"
                    if (cand.expr.endsWith(bName)) continue;

                    for (let p = STEP_SIZE; p < 100; p += STEP_SIZE) {
                        let nCmyk = cmykMix(cand.cmyk, bCmyk, p);
                        let nRgb = cmykToRgbNaive(nCmyk);
                        nextGen.push({
                            gap: getGap(nRgb),
                            cmyk: nCmyk,
                            expr: `${cand.expr}!${p}!${bName}`,
                            rgb: nRgb
                        });
                    }
                }
            }
            
            if (nextGen.length > 0) {
                nextGen.sort((a,b) => a.gap - b.gap);
                bestResults.push(nextGen[0]);
                currentGen = nextGen; // Pass forward for next depth if needed
            }
        }

        // Render Results
        tableBody.innerHTML = '';
        bestResults.sort((a,b) => a.gap - b.gap);
        
        // Update "Best Match" preview
        let top = bestResults[0];
        let topHex = '#' + top.rgb.map(x => Math.round(x*255).toString(16).padStart(2,'0')).join('');
        document.getElementById('resultPreview').style.backgroundColor = topHex;
        
        // Populate Table
        bestResults.forEach((res, idx) => {
            let hex = '#' + res.rgb.map(x => Math.round(x*255).toString(16).padStart(2,'0')).join('');
            let row = `<tr>
                <td>${idx + 1}</td>
                <td>${res.gap.toFixed(2)}</td>
                <td><div class="vis-box" style="background:${hex}"></div>${hex}</td>
                <td><code>\\colorbox{${res.expr}}{...}</code></td>
            </tr>`;
            tableBody.innerHTML += row;
        });

    } catch (e) {
        alert("Error: " + e.message);
        console.error(e);
    } finally {
        btn.disabled = false;
        spinner.style.display = 'none';
    }
}
</script>
</body>
</html>
